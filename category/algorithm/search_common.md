binary search func

1. [x]  find a single number
2. [x]  find left_bound  
3. [x]  find right_bound

主要思想: 
	是通过一种 压缩 合法区间, 这个合法区间 可以是各种满足的条件，最简单的就是满足找到某个值即可, 稍微比较复杂就是找到满足条件的左边界或者
右边界。
除了一些比较明显的求值，求边界的情况，还有一些情况是需要你去泛化场景，泛化到 x -> f(x) ==> x在f(x) 单调，从而求的满足f(x)在什么值,也就是
可以得到f(x) 是有二段性的， f(x) 满足某个值，和不满足某个值

Practices:

* 找到 K 个最接近的元素 (658)
```go
//给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。
//
//整数 a 比整数 b 更接近 x 需要满足：
//
//|a - x| < |b - x| 或者
//|a - x| == |b - x| 且 a < b
//
//输入：arr = [1,2,3,4,5], k = 4, x = 3
//输出：[1,2,3,4]
```

* 搜索旋转排序数组, 分别思考有重复数据和没有重复数据的情况(33)
```go
// nums[i] 满足 nums[i] >= nums[i-1] 
// nums 随意进行旋转之后， 再找target 值 
func (nums []int, target int) bool {
	
}
 
```
满足这类问题的抽象是自变量x 都可以有一个 "二段性"

* 爱吃香蕉的珂珂(875)
```go
//珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有piles[i]根香蕉。警卫已经离开了，将在 h 小时后回来。
//珂珂可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  
//珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
//返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。
//
//输入：piles = [3,6,7,11], h = 8
//输出：4


```
* 在 D 天内送达包裹的能力(1011)
```go
//传送带上的包裹必须在 days 天内从一个港口运送到另一个港口。
//传送带上的第i个包裹的重量weights[i]。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。
//返回能在 days 天内将传送带上的所有包裹送达的船的最低运载能力。

//输入：weights = [1,2,3,4,5,6,7,8,9,10], days = 5
//输出：15
//解释：
//船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：
//第 1 天：1, 2, 3, 4, 5
//第 2 天：6, 7
//第 3 天：8
//第 4 天：9
//第 5 天：10

```
* 分割数组的最大值（410）
```go
//给定一个非负整数数组 nums 和一个整数m ，你需要将这个数组分成m个非空的连续子数组。
//设计一个算法使得这m个子数组各自和的最大值最小。
//
//示例 1：
//输入：nums = [7,2,5,10,8], m = 2
//输出：18
//解释：
//一共有四种方法将 nums 分割为 2 个子数组。 
//其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。
//因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。
```